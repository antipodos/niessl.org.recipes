# Research: Flutter Recipe App

**Branch**: `001-flutter-recipe-app` | **Date**: 2026-02-19
**Phase**: 0 — Outline & Research

---

## 1. API Structure Discovery

### Decision
Consume the existing dinner.niessl.org JSON endpoints directly without any backend proxy.

### Endpoint inventory (verified via live fetch)

| Endpoint | Response shape | Notes |
|----------|---------------|-------|
| `https://dinner.niessl.org/recipes/index.json` | `[{name, url}, ...]` | 89 recipes |
| `https://dinner.niessl.org/tags/index.json` | `[{name, url}, ...]` | 6 tags |
| `https://dinner.niessl.org/tags/{tag}/index.json` | `[{name, url}, ...]` | recipes per tag |
| `https://dinner.niessl.org/recipes/{slug}/index.json` | `{name, recipe}` | markdown content |

### Key findings
- Recipe index: flat array of `{name: string, url: string}`. No tags embedded.
- Recipe detail: `{name: string, recipe: string}` where `recipe` is plain Markdown.
- Tag index: 6 tags — `sweet`, `basis`, `indian`, `main`, `snack`, `fish`.
- Each tag URL returns a recipe list in the same `{name, url}` format.
- To associate tags with recipes, we MUST fetch each of the 6 tag indices.
  URL is the natural join key between the two lists.
- No authentication required; all endpoints are public.
- No pagination; all recipes returned in a single response.

### Rationale
The API is a read-only static JSON interface generated by Hugo. Since there are only
89 recipes and 6 tags, fetching all 8 indices (recipe index + tags index + 6 tag
indices) in parallel on startup is fast and gives us full in-memory data with tag
associations — no lazy per-tag network calls needed during filtering.

### Alternatives considered
- Proxy backend to add a tag field to each recipe: rejected — unnecessary complexity,
  no server infrastructure needed.
- Fetch tag indices lazily on filter select: rejected — user would see a network delay
  when tapping a tag, which violates the "instantaneous filtering" requirement.

---

## 2. State Management

### Decision
**Riverpod 2.x** without code generation (no build_runner).

### Recommended package
```
flutter_riverpod: ^2.4.0
```

### Pattern
- `FutureProvider` for async data (recipe index, tag associations)
- `StateProvider<String>` for search query
- `StateProvider<Set<String>>` for selected tag names
- `Provider<List<RecipeSummary>>` (derived) for the filtered list
- `.autoDispose` where appropriate (detail screen provider)

### Rationale
Riverpod 2.x is the current Flutter standard for reactive state. The non-code-gen
API (`StateProvider`, `FutureProvider`, `Provider`) is sufficient for a 3-screen app
and requires zero build tooling. Provider (older) is less ergonomic. BLoC is too
verbose for this scale.

### Alternatives considered
- **Provider**: simpler to learn but harder to compose async state; deprecated in
  favour of Riverpod by its own author.
- **flutter_bloc**: excellent for strict event-driven apps; overkill for 3 screens
  and simple derived state.
- **Riverpod with code generation**: avoids some typos but adds build_runner step
  to the workflow; not worth the overhead for a small project.

---

## 3. Markdown Rendering

### Decision
**flutter_markdown** (official Google/Flutter package).

### Recommended package
```
flutter_markdown: ^0.7.0
```

### Rationale
Official, actively maintained, handles all markdown used in the recipe content
(`##` headers, `*` bullet lists, numbered lists). No configuration required —
`MarkdownBody(data: recipe)` renders correctly out of the box. `markdown_widget`
is a viable alternative but less maintained.

---

## 4. HTTP Client

### Decision
**`http` package** (official Dart package).

### Recommended package
```
http: ^1.2.0
```

### Rationale
All network calls are simple `GET` requests returning JSON. No interceptors, auth
headers, retry logic, or multipart uploads are needed. The `http` package is the
official, minimal-dependency choice. `dio` adds interceptors, cancellation tokens,
and other features that are unnecessary here.

---

## 5. Local Cache

### Decision
**`shared_preferences`** for the recipe index, tag maps, and cached recipe content.

### Recommended package
```
shared_preferences: ^2.3.0
```

### Cache key strategy
| Key | Value |
|-----|-------|
| `cache_recipes_index` | JSON string — full recipe index array |
| `cache_tags_map` | JSON string — map of tagName → [recipeUrl, ...] |
| `cache_recipe_{urlHash}` | JSON string — individual recipe detail |
| `cache_timestamp` | ISO datetime string — when cache was last refreshed |

### Rationale
The total data volume is small: ~89 recipes × ~600 chars of markdown = ~54 KB
maximum if all details are cached. This is well within shared_preferences limits.
The recipe index + tag maps are a few KB. No structured query is needed, so a
key-value store is perfectly adequate. `hive` or `objectbox` would add complexity
without benefit at this scale.

### Cache policy
- On cold start: serve cached data immediately, then refresh in background.
- On pull-to-refresh: force network refresh, update cache.
- No expiry: data is updated only by a new version of the Hugo site; manual
  refresh is sufficient.

---

## 6. Screen Keep-Alive

### Decision
**`wakelock_plus`** package.

### Recommended package
```
wakelock_plus: ^1.2.0
```

### Integration points
- Enable: `WakelockPlus.enable()` when user turns on the toggle in detail view.
- Disable: `WakelockPlus.disable()` in the `dispose()` of the detail screen (or
  when navigating back), ensuring it is always cleaned up.

### Platform config required
- Android: add `WAKE_LOCK` permission to `AndroidManifest.xml`.
- iOS: no extra config needed (managed by UIApplication).

### Alternatives considered
- `wakelock`: deprecated; `wakelock_plus` is its successor.
- Manual platform channel: unnecessary when a maintained plugin exists.

---

## 7. Typography & Theme

### Decision
Material Design 3 with a warm color seed and the system font stack. No Google
Fonts dependency added — keeping the package footprint small.

### Theme approach
- `useMaterial3: true`
- `ColorScheme.fromSeed(seedColor: Color(0xFFB85C38))` — warm terracotta
- `ThemeMode.system` — auto light/dark
- All colors, spacing, and typography come from the Material 3 theme; no
  hard-coded values in widget code.

### Rationale
Material 3 provides a complete, consistent design system out of the box. Adding
a Google Fonts dependency for a recipe app increases APK size and adds a network
call on first load for font fetching. The system font looks clean and modern on
both iOS (San Francisco) and Android (Roboto/Google Sans).

---

## 8. Project Structure

### Decision
Single Flutter project at repository root. Flat, minimal layer structure.

```
lib/
├── main.dart                      # App entry, theme, MaterialApp
├── theme.dart                     # ThemeData definition
├── models/
│   └── recipe.dart                # RecipeSummary, RecipeDetail, Tag
├── services/
│   └── recipe_service.dart        # HTTP fetching + cache read/write
├── providers/
│   └── providers.dart             # All Riverpod providers
├── screens/
│   ├── recipe_list_screen.dart    # US1 + US2 + US3
│   └── recipe_detail_screen.dart  # US1 detail + US4 wakelock
└── widgets/
    ├── recipe_tile.dart           # List item widget
    ├── tag_chip_bar.dart          # Horizontal tag filter chips
    ├── search_bar_widget.dart     # Search input
    ├── loading_view.dart          # Shared loading state
    ├── error_view.dart            # Shared error state + retry
    └── empty_state_view.dart      # No results state

test/
├── unit/
│   ├── recipe_service_test.dart   # Mocked HTTP, cache logic
│   └── filter_logic_test.dart    # Search + tag filter correctness
└── integration/
    └── app_test.dart              # Full user story flows
```

### Rationale
No repository pattern, no use-case layer, no separate `domain/` package. With one
data source (the public JSON API), one service class is sufficient. Riverpod
providers ARE the view-model layer. Adding intermediate layers for 3 screens would
be premature abstraction (Rule of Three violation). User said "not overengineered —
keep it simple."

---

## 9. NEEDS CLARIFICATION — Resolved

All technical unknowns have been resolved above. No open NEEDS CLARIFICATION items.

---

## 10. Dependency Summary

```yaml
dependencies:
  flutter:
    sdk: flutter
  flutter_riverpod: ^2.4.0   # state management
  http: ^1.2.0               # HTTP GET requests
  flutter_markdown: ^0.7.0   # recipe content rendering
  shared_preferences: ^2.3.0 # local caching
  wakelock_plus: ^1.2.0      # screen keep-alive

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0     # linting (constitution Principle I)
  integration_test:
    sdk: flutter
```

Total added dependencies: 5. Intentionally minimal.
